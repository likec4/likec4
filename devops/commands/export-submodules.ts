import { defineCommand } from 'citty'
import Gitignore, { type State as GitignoreState } from 'parse-gitignore'
import { entries, isPlainObject, isString } from 'remeda'
import type { PackageJson } from 'type-fest'
import { $, chalk, echo, fs, path } from 'zx'

type SubModuleExport = { types: string; module?: string | undefined }

/**
 * Resolves the exports
 * @example
 * ```json
 * {
 *   "exports": {
 *     "./builder": {
 *       "sources": "./src/builder/index.ts",
 *       "default": {
 *         "types": "./dist/builder/index.d.mts",
 *         "import": "./dist/builder/index.mjs",
 *         "default": "./dist/builder/index.mjs"
 *       }
 *     }
 *   ///
 * }
 * ```
 * ```typescript
 *
 * const result = resolveExport(exports['./builder'])
 * // result = {
 * //   types: './dist/builder/index.d.mts',
 * //   module: './dist/builder/index.mjs'
 * // }
 * ```
 */
function resolveExports(exports: PackageJson.Exports): null | SubModuleExport {
  if (!exports || !isPlainObject(exports)) {
    return null
  }
  if ('default' in exports && isPlainObject(exports.default)) {
    return resolveExports(exports.default)
  }
  const types = exports['types']
  const module = exports['module'] ?? exports['import'] ?? exports['default']

  if (isString(types)) {
    if (isString(module)) {
      return {
        types: path.resolve(types),
        module: path.resolve(module),
      }
    }
    return {
      types: path.resolve(types),
    }
  }

  return null
}

async function loadGitignore(): Promise<{ gitignore: GitignoreState; ignored: string[] }> {
  let gitignore: GitignoreState
  if (fs.existsSync('.gitignore')) {
    gitignore = Gitignore.parse(await fs.readFile('.gitignore', 'utf-8'))
  } else {
    gitignore = {
      patterns: [],
      sections: [],
    }
  }
  const name = 'Auto-generated by likec4ops export-submodules'
  const comment = `# ${name}`
  let section = gitignore.sections.find(section => section.name === name || (section as any).comment === comment)
  if (!section) {
    section = {
      name,
      patterns: [],
    }
    gitignore.sections.push(section)
    ;(section as any).comment = comment
  }

  return { gitignore, ignored: section.patterns }
}

function relativeExports(
  submodulePath: string,
  { types, module }: SubModuleExport,
): SubModuleExport {
  return {
    types: path.relative(submodulePath, types),
    ...(module && { module: path.relative(submodulePath, module) }),
  }
}

function existCheck(path: string) {
  if (fs.existsSync(path)) {
    return 'exists'
  }
  return '❌ missing'
}

export default defineCommand({
  meta: {
    name: 'export-submodules',
    description: 'Create folders with "package.json"s, mimicking submodules exports. Helpful for TS Module Resolution',
  },
  args: {
    cwd: {
      type: 'string',
      description: 'change working directory',
      required: false,
    },
  },
  async run({ args }) {
    process.env.FORCE_COLOR = '1'
    $.preferLocal = true
    $.verbose = true

    if (args.cwd && args.cwd !== '.') {
      $.cwd = path.resolve('.', args.cwd)
      echo(chalk.green('⚙️ cwd') + ` ${$.cwd}`)
    }

    echo(chalk.green('read package.json'))

    const packageJson: PackageJson = await fs.readJson('package.json')
    const pkgExports = packageJson.exports
    if (!pkgExports || !isPlainObject(pkgExports)) {
      throw new Error('Invalid exports in package.json')
    }

    const created = new Set<string>()

    const { gitignore, ignored } = await loadGitignore()

    for (let [key, exports] of entries(pkgExports)) {
      if (key === '.' || key.endsWith('/*') || key.endsWith('/') || !exports || isString(exports)) {
        echo(chalk.dim.cyan('skip') + ' ' + chalk.dim(key))
        continue
      }
      const resolved = resolveExports(exports)
      if (!resolved) {
        echo(chalk.red('skip invalid export') + ' ' + chalk.dim(key))
        continue
      }
      if (path.basename(resolved.types) === $.cwd && (!resolved.module || path.basename(resolved.module) === $.cwd)) {
        echo(chalk.dim.cyan('skip') + ' ' + chalk.dim(key))
        echo(chalk.dim(' No need to create package.json for current submodule'))
        continue
      }

      const submoduleName = key.slice(2)
      const submodule = relativeExports(path.resolve(key), resolved)

      const submodulePackageJson = submoduleName + '/package.json'
      echo(chalk.cyan('create') + ' ' + chalk.dim(submodulePackageJson))

      const maxLength = Math.max(submodule.types.length, submodule.module?.length ?? 0) + 1

      echo(chalk.dim('  types:  ') + submodule.types.padEnd(maxLength) + chalk.dim(existCheck(resolved.types)))

      if (resolved.module && submodule.module) {
        echo(chalk.dim('  module: ') + submodule.module.padEnd(maxLength) + chalk.dim(existCheck(resolved.module)))
      } else {
        echo(chalk.dim('  module: ') + chalk.red('undefined'))
      }

      // Try to read the existing package.json
      if (fs.existsSync(submodulePackageJson) && !ignored.includes(submodulePackageJson)) {
        echo(chalk.red('  package.json exists, but not in .gitignore'))
      }

      await fs.mkdirp(submoduleName)
      await fs.writeJson(submodulePackageJson, submodule, { spaces: 2 })

      created.add(submodulePackageJson)
      echo('')
    }

    if (created.size !== ignored.length || ignored.some(i => !created.has(i))) {
      echo('')
      echo(chalk.cyan('update .gitignore'))
      // Mutate array
      ignored.length = 0
      ignored.push(...created)

      const content = Gitignore.format(gitignore as any)

      echo(chalk.dim(content))

      await fs.writeFile('.gitignore', content)
    } else {
      echo(chalk.dim.cyan('no changes to .gitignore'))
    }

    // Validate package.json
    if (created.size > 0) {
      // Check package.json
      if (packageJson.type !== 'module') {
        echo(chalk.red(' ❌ package.json must have "type: module"'))
        process.exit(1)
      }
      if (!packageJson.types || !packageJson.module) {
        echo(chalk.red(' ❌ package.json must have types and module'))
        process.exit(1)
      }
      if (!packageJson.files?.includes('**/package.json')) {
        if (!fs.existsSync('.npmignore')) {
          echo(chalk.red(' ❌ package.json must include files: ["**/package.json"]'))
          process.exit(1)
        }

        const npmignore = await fs.readFile('.npmignore', 'utf-8').catch(() => '')
        if (!npmignore.includes('!**/package.json')) {
          echo(chalk.red(' ❌ .npmignore must have: "!**/package.json"'))
          process.exit(1)
        }
      }
    }

    echo(chalk.green('✅ done'))
  },
})
