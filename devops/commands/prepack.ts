import { defineCommand } from 'citty'
import Gitignore, { type State as GitignoreState } from 'parse-gitignore'
import { entries, hasSubObject, isPlainObject, isString } from 'remeda'
import type { PackageJson } from 'type-fest'
import { $, chalk, echo, fs, path } from 'zx'

type SubModuleExport = { types: string; module?: string | undefined }

/**
 * Resolves the exports
 * @example
 * ```json
 * {
 *   "exports": {
 *     "./builder": {
 *       "sources": "./src/builder/index.ts",
 *       "default": {
 *         "types": "./dist/builder/index.d.mts",
 *         "import": "./dist/builder/index.mjs",
 *         "default": "./dist/builder/index.mjs"
 *       }
 *     }
 *   ///
 * }
 * ```
 * ```typescript
 *
 * const result = resolveExport(exports['./builder'])
 * // result = {
 * //   types: './dist/builder/index.d.mts',
 * //   module: './dist/builder/index.mjs'
 * // }
 * ```
 */
function getSubmoduleExports(exports: PackageJson.Exports): null | SubModuleExport {
  if (!exports || !isPlainObject(exports)) {
    return null
  }
  if ('default' in exports && isPlainObject(exports.default)) {
    return getSubmoduleExports(exports.default)
  }
  const types = exports['types']
  const module = exports['module'] ?? exports['import'] ?? exports['default']

  if (isString(types)) {
    return Object.assign(
      { types },
      isString(module) && { module },
    )
  }

  return null
}

function resolveExports(exports: PackageJson.Exports): null | SubModuleExport {
  const submodule = getSubmoduleExports(exports)
  if (!submodule) {
    return null
  }
  const { types, module } = submodule
  return {
    types: path.resolve(types),
    ...(module && { module: path.resolve(module) }),
  }
}

function cutPrefix(submodule: SubModuleExport): SubModuleExport {
  const cut = (v: string) => v.startsWith('./') ? v.slice(2) : v
  return {
    types: cut(submodule.types),
    ...(submodule.module && { module: cut(submodule.module) }),
  }
}

export async function loadPrepackGitignore(): Promise<{ gitignore: GitignoreState; prepackIgnored: string[] }> {
  let gitignore: GitignoreState
  if (fs.existsSync('.gitignore')) {
    gitignore = Gitignore.parse(await fs.readFile('.gitignore', 'utf-8'))
  } else {
    gitignore = {
      patterns: [],
      sections: [],
    }
  }
  const name = 'Auto-generated by likec4ops prepack'
  const comment = `# ${name}`
  let section = gitignore.sections.find(section => section.name === name || (section as any).comment === comment)
  if (!section) {
    section = {
      name,
      patterns: [],
    }
    gitignore.sections.push(section)
    ;(section as any).comment = comment
  }

  return { gitignore, prepackIgnored: section.patterns }
}

function relativeExports(
  submodulePath: string,
  { types, module }: SubModuleExport,
): SubModuleExport {
  return {
    types: path.relative(submodulePath, types),
    ...(module && { module: path.relative(submodulePath, module) }),
  }
}

function existCheck(path: string) {
  if (fs.existsSync(path)) {
    return 'exists'
  }
  return '❌ missing'
}

export default defineCommand({
  meta: {
    name: 'prepack',
    description: 'Create folders with "package.json"s, for compatibility with different Module Resolution strategies',
  },
  args: {
    // cwd: {
    //   type: 'string',
    //   description: 'change working directory',
    //   required: false,
    // },
  },
  async run({ args }) {
    process.env.FORCE_COLOR = '1'
    $.preferLocal = true
    $.verbose = true

    $.cwd = process.cwd()

    echo(chalk.green('⚙️ cwd') + ` ${$.cwd}`)
    echo(chalk.green('read package.json'))

    const packageJson: PackageJson = await fs.readJson('package.json')
    const pkgExports = packageJson.exports
    if (!pkgExports || !isPlainObject(pkgExports)) {
      throw new Error('Invalid exports in package.json')
    }

    // Check package.json
    if (packageJson.type !== 'module') {
      echo(chalk.red(' ❌ package.json must have "type: module"'))
      process.exit(1)
    }

    // Validate exports
    const indexExport = pkgExports['.']
    if (!indexExport) {
      throw new Error('Invalid exports in package.json, missing "."')
    }
    if (!isString(indexExport)) {
      const resolved = getSubmoduleExports(indexExport)
      if (!resolved || !resolved.module) {
        throw new Error('Invalid exports "." in package.json')
      }
      echo(chalk.cyan('validate index export'))
      echo(chalk.dim('  types:  ') + resolved.types)
      echo(chalk.dim('  module: ') + resolved.module)

      const cutted = cutPrefix(resolved)

      if (!hasSubObject(packageJson.publishConfig ?? {}, cutted)) {
        echo(chalk.red.dim('  not in publishConfig'))
        if (!hasSubObject(packageJson, cutted)) {
          echo(chalk.red('  not in package.json'))
          process.exit(1)
        } else {
          echo(chalk.dim('  found in package.json'))
        }
      } else {
        echo(chalk.dim('  found in publishConfig'))
      }
      echo('')
    }

    const created = [] as string[]

    const { gitignore, prepackIgnored } = await loadPrepackGitignore()

    for (let [key, exports] of entries(pkgExports)) {
      if (key === '.' || key.endsWith('/*') || key.endsWith('/') || !exports || isString(exports)) {
        echo(chalk.cyan('skip'.padEnd(7)) + ' ' + chalk.dim(key))
        continue
      }
      const resolved = resolveExports(exports)
      if (!resolved) {
        echo(chalk.red('skip invalid export') + ' ' + chalk.dim(key))
        continue
      }
      const submoduleName = key.slice(2)
      if (path.dirname(resolved.types) === $.cwd) {
        echo(chalk.cyan('skip'.padEnd(7)) + ' ' + chalk.dim(submoduleName))
        echo(chalk.dim('  Submodule is in the current directory\n'))
        continue
      }
      const submodule = relativeExports(path.resolve(key), resolved)

      const submodulePackageJson = submoduleName + '/package.json'
      echo(chalk.cyan('create') + ' ' + chalk.dim(submodulePackageJson))

      const maxLength = Math.max(submodule.types.length, submodule.module?.length ?? 0) + 1

      echo(chalk.dim('  types:  ') + submodule.types.padEnd(maxLength) + chalk.dim(existCheck(resolved.types)))

      if (resolved.module && submodule.module) {
        echo(chalk.dim('  module: ') + submodule.module.padEnd(maxLength) + chalk.dim(existCheck(resolved.module)))
      } else {
        echo(chalk.dim('  module: ') + chalk.red('undefined'))
      }

      // Try to read the existing package.json
      if (fs.existsSync(submodulePackageJson) && !prepackIgnored.includes(submodulePackageJson)) {
        echo(chalk.red('  package.json exists, but not in .gitignore'))
        echo(chalk.red('  Skip it and continue, you can change it manually\n'))
        continue
      }

      await fs.mkdirp(submoduleName)
      await fs.writeJson(submodulePackageJson, submodule, { spaces: 2 })

      created.push(submodulePackageJson)
      echo('')
    }

    echo('')

    if (created.length !== prepackIgnored.length || prepackIgnored.some(i => !created.includes(i))) {
      echo(chalk.green('update .gitignore'))
      // Mutate array
      prepackIgnored.length = 0
      prepackIgnored.push(...created)

      const content = Gitignore.format(gitignore as any)

      echo(chalk.dim(content))

      await fs.writeFile('.gitignore', content)
    } else {
      echo(chalk.cyan('no changes to .gitignore'))
    }

    // Validate package.json
    if (created.length > 0) {
      if (!packageJson.files?.includes('**/package.json')) {
        if (!fs.existsSync('.npmignore')) {
          echo(chalk.red(' ❌ package.json must include files: ["**/package.json"]'))
          process.exit(1)
        }

        const npmignore = await fs.readFile('.npmignore', 'utf-8').catch(() => '')
        if (!npmignore.includes('!**/package.json')) {
          echo(chalk.red(' ❌ .npmignore must have: "!**/package.json"'))
          process.exit(1)
        }
      }
    }

    echo('')

    echo(chalk.green('✅ done'))
  },
})
